import argparse
import nibabel as nb
import numpy as np
import os.path
import re

from math import exp

def get_weight(fd_i):
	return 1 / fd_i if fd_i >= .01 else 100


def get_cbf_scalar(partition_coeff, R1a, tag_eff, pld, label_pulse):
	return (6000 * partition_coeff * R1a) / (2 * tag_eff * (exp(-pld * R1a) - exp(-(label_pulse + pld) * R1a))) # mL/100g/min


def calc_cbf(patid, asl_run, filename, T1=1650, seq2d=False, TR=None, num_slices=None, smooth=(), pld_img=None):
	imgroot = filename.split('.')[0]
	img = nb.load(filename)
	imgdata = img.get_data()

	# cbf calculation constants
	R1a = 1000. / T1
	partition_coeff = .9 # g/ml
	rf_blocks = 82
	label_pulse = .0184 * rf_blocks # seconds

	if smooth:
		smooth = np.trim_zeros(smooth)
		mid_kernel_idx = len(smooth)//2

		# split all_fd into separate arrays for each run and grab current run's data starting from first tag
		all_fd = np.genfromtxt('../movement/{}_asl_xr3d.FD'.format(patid), usecols=0)
		split_indices = np.where(all_fd==500)[0] # grab first element of tuple to get row indices
		if len(split_indices) < asl_run:
			raise 'There are not enough runs in FD file for specified run number'
		fd = np.split(all_fd, split_indices)[asl_run][2:]

	if seq2d:
		if not (TR and num_slices):
			raise 'TR and num_slices are required when using the 2d sequence'

		plddata = nb.load(pld_img).get_data()

		tag_eff = .85
		#tacq = (TR - label_pulse - post_label_delay) / num_slices # need to take into account when slice was acquired for 2d sequence
		#print(tacq)
		ctl_frames = np.take(imgdata, range(1, imgdata.shape[3], 2), axis=3)
		M0 = np.average(ctl_frames, axis=3)
	else:
		tag_eff = .80
		tacq = 0
		M0 = imgdata[:,:,:,0]
		imgdata = imgdata[:,:,:,2:]

	out_frames = imgdata.shape[3] // 2

	# calculate CBF using simple subtraction perfusion
	perfdata = np.empty(img.shape[:3] + tuple([out_frames]))
	cbfdata = np.empty_like(perfdata)
	for i in range(1, imgdata.shape[3], 2):
		pair_idx = i // 2
		if not smooth:
			ctrl_i = imgdata[:,:,:,i]
			tag_i = imgdata[:,:,:,i-1]
		else:
			ctrl_i, tag_i = 0, 0
			ctrl_weights, tag_weights = [], []

			for j in range(len(smooth)):
				if (i-1+j < mid_kernel_idx) or (i+j >= imgdata.shape[3]+mid_kernel_idx): # skip backward/forward weighting when there is no previous/next
					continue

				kernel_idx = i + (2 * (j - mid_kernel_idx)) # want correction to be between "like" frames (i.e. tag to tag, ctl to ctl)
				ctrl_weights.append(smooth[j] * get_weight(fd[kernel_idx]))
				ctrl_i += ctrl_weights[-1] * imgdata[:,:,:,kernel_idx]
				tag_weights.append(smooth[j] * get_weight(fd[kernel_idx-1]))
				tag_i += tag_weights[-1] * imgdata[:,:,:,kernel_idx-1]

			ctrl_i /= sum(ctrl_weights)
			tag_i /= sum(tag_weights)

		perfdata[:,:,:,pair_idx] =  ctrl_i - tag_i

		if not seq2d:
			c = get_cbf_scalar(partition_coeff, R1a, .8, 2, label_pulse)
		else:
			c = np.zeros_like(imgdata[:,:,:,0])
			pld = np.mean(plddata[:,:,:,i-1:i+1], axis=3)
			for x in range(imgdata.shape[0]):
				for y in range(imgdata.shape[1]):
					for z in range(imgdata.shape[2]):
						#pld = 1.5 + (z*.035)
						c[x,y,z] = get_cbf_scalar(partition_coeff, R1a, .85, pld[x,y,z], label_pulse)
		imgdiv = np.divide(perfdata[:,:,:,pair_idx], M0, out=np.zeros_like(perfdata[:,:,:,pair_idx]), where=M0 != 0)
		cbfdata[:,:,:,pair_idx] = c * imgdiv

	perfimg = nb.Nifti1Image(perfdata, img.affine, nb.Nifti1Header())
	nb.save(perfimg, imgroot + '_perf.nii')

	cbfimg = nb.Nifti1Image(cbfdata, img.affine, nb.Nifti1Header())
	nb.save(cbfimg, imgroot + '_cbf.nii')

	avgcbfdata = np.mean(cbfdata, axis=3)
	avgcbfimg = nb.Nifti1Image(avgcbfdata, img.affine, nb.Nifti1Header())
	nb.save(avgcbfimg, imgroot + '_cbf_avg.nii')


if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument('patid')
	parser.add_argument('asl_run', type=int, help='which run is the image for (1-indexed)')
	parser.add_argument('filename', help='atlas-aligned brainmasked asl image (nii)')
	parser.add_argument('--T1', type=float, default=1650, help='pre-calculated (using image generated by Fast IR sequence) T1 in ms')
	parser.add_argument('--seq2d', action='store_true', help='if the 2d pcasl sequence was used')
	parser.add_argument('--TR', type=float, help='TR of ASL sequence; used for 2d pcasl CBF calculation')
	parser.add_argument('--num_slices', type=int, help='number of slices')
	parser.add_argument('--smoothing_kernel', type=int, nargs='+', default=(), help='temporal smoothing tuple')
	parser.add_argument('--pld_img')
	args = parser.parse_args()

	if args.seq2d and not (args.TR and args.num_slices):
		parser.error('TR and num_slices are required when using the 2d sequence')

	if args.asl_run < 1:
		parser.error('asl_run indexing starts at 1')

	calc_cbf(args.patid, args.asl_run, args.filename, args.T1, args.seq2d, args.TR, args.num_slices, tuple(args.smoothing_kernel), args.pld_img)
